/*

Создайте функцию getData. У неё должно быть два параметра. Первый параметр — массив с ключами. Второй — массив с массивами данных.
Функция должна собрать объект для каждого массива значений. Каждый из этих объектов должен быть записан в массив.
Именно этот массив с объектами должна вернуть функция getData.
Каждому элементу из массива ключей подходит элемент с таким же индексом в массиве значений.
Есть один нюанс: значений может оказаться больше или меньше, чем ключей.
Если значений не хватает, то создавать пустой ключ не надо. А если значений больше, то их не нужно включать в объект — для них нет ключей.

*/

// Массив ключей
let keys = ['имя', 'любимый цвет', 'любимое блюдо'];

// Массив значений
let data = [
  ['Василий', 'красный', 'борщ'],
  ['Мария'],
  ['Иннокентий', 'жёлтый', 'пельмени', '18', 'Азовское']
];


let getData = function(keys, data) {
  let newData = [];
  for (let elem of data) {
      let obj = {}; // Создаем новый объект для каждой строки данных
      for (let i = 0; i < keys.length; i++) {
          if (elem[i]) {  // Проверяем, что значение существует
              obj[keys[i]] = elem[i];   // Добавляем пару ключ-значение в объект
          }
      }
      newData.push(obj); // Добавляем объект в итоговый массив
  }
  return newData; // Возвращаем массив объектов
};
  
 

// function getData(keys, data) {
  
//   return data.map(elem => {
//     let obj = {};
//     keys.forEach((key, index) => {
//       if (elem) {
//         obj[key] = elem[index];
//       }
//     });
//     return obj;
//   });
// }

function getData(keys, data) {
  return data.map(elem => Object
    .fromEntries(keys
    .map((key, i) => [key, elem[i]])
    .filter(([, val]) => val)));
}

// console.log(getData(keys, data))
